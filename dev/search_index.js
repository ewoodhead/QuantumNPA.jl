var documenterSearchIndex = {"docs":
[{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Maximise CHSH at level 2 of the hierarchy:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> @dichotomic A1 A2 B1 B2;\n\njulia> S = A1*(B1 + B2) + A2*(B1 - B2)\nA1 B1 + A1 B2 + A2 B1 - A2 B2\n\njulia> npa_max(S, 2)\n2.828227712681755","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Maximise Svetlichny at level 1 + A B + A C + B C:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> @dichotomic A[1:2] B[1:2] C[1:2];\n\njulia> E(x,y,z) = A[x]*B[y]*C[z]\nE (generic function with 1 method)\n\njulia> S = -E(1,1,1) + E(1,1,2) + E(1,2,1) + E(1,2,2) + E(2,1,1) + E(2,1,2) + E(2,2,1) - E(2,2,2)\n-A1 B1 C1 + A1 B1 C2 + A1 B2 C1 + A1 B2 C2 + A2 B1 C1 + A2 B1 C2 + A2 B2 C1 - A2 B2 C2\n\njulia> npa_max(S, \"1 + A B + A C + B C\")\n5.656854315137034","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(note that the spaces e.g. between A and B are necessary in the string, since party labels go from A to Z then AA to ZZ then AAA to ZZZ...)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Maximise a modified CHSH at level 1 + A B + A^2 B:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> npa_max(0.3 * A1 + 0.6 * A1*(B1 + B2) + A2*(B1 - B2), \"1 + A B + A^2 B\")\n2.3584761820283977","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"You can specify both equality and inequality arguments using the eq and ge keyword arguments. These should be lists of operators whose expectation values you want, respectively, to set to and lower bound by zero. For example, to maximise <A1> subject to <A1*(B1 + B2)> = 1.4 and <A2*(B1 - B2)> = 1.4:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> npa_max(A1, 2, eq=[A1*(B1 + B2) - 1.4*Id, A2*(B1 - B2) - 1.4*Id])\n0.19800616634180992","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Maximise <A1 + A2> subject to <A1 + 2*A2> <= 1 and <2*A1 + A2> <= 1:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> npa_max(A1 + A2, 1, ge=[Id - A1 - 2*A2, Id - 2*A1 - A2])\n0.6666666597867417","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Maximise <A1 + A2> subject to <A1> = <A2> and <A1 + 2*A2> <= 1:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> npa_max(A1 + A2, 1, eq=[A1 - A2], ge=[1 - A1 - 2*A2])\n0.666642228695571","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The above examples all use dichotomic variables, but projectors are also supported. Here we maximise the CH74 form of CHSH:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> PA11, PA12 = projector(1,1,1:2);\n\njulia> PB11, PB12 = projector(2,1,1:2);\n\njulia> npa_max(-PA11 - PB11 + PA11*(PB11 + PB12) + PA12*(PB11 - PB12), 1)\n0.20701116471401693\n\njulia> (sqrt(2) - 1)/2\n0.20710678118654757","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Maximise CGLMP with d=3 at level 1 + A B:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> npa_max(cglmp(3), \"1 + A B\")\n2.914945976226541\n\njulia> 1 + sqrt(11/3)\n2.914854215512676","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This uses a function cglmp() already defined in qnpa.jl to construct the CGLMP operator.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Maximise the global guessing probability P_textguess(A1B1E) in the CHSH setting using full statistics:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Create projectors. The keyword argument 'full=true' means that the\n# operator corresponding to the highest-numbered output is directly set to\n# the identity minus the other ones. For example,\n#\n#   PA[2,1] = Id - PA[1,1]\n#\n# and\n#\n#   PE[4] = Id - PE[1] - PE[2] - PE[3]\n#\n# This is meant to make working in the Collins-Gisin projection (which the\n# NPA code uses) more convenient.\nPA = projector(1, 1:2, 1:2, full=true)\nPB = projector(2, 1:2, 1:2, full=true)\nPE = projector(5, 1:4, 1, full=true)\n\n# CHSH = 2*sqrt(2) * p\np = 0.9\n\n# Expectation value of G is the probability that Eve correctly guesses\n# Alice's and Bob's joint outcome.\nG = sum(PA[a,1] * PB[b,1] * PE[2*(a-1) + b]\n        for a in 1:2 for b in 1:2)\n\n# Ideal CHSH-violating correlations mixed with noise. N.B., the actual\n# constraints imposed are on the expectation values of the operators\n# in the array.\nconstraints = [PA[1,1] - 0.5*Id,\n               PA[1,2] - 0.5*Id,\n               PB[1,1] - 0.5*Id,\n               PB[1,2] - 0.5*Id,\n               PA[1,1]*PB[1,1] - 0.25*(1 + p/sqrt(2))*Id,\n               PA[1,1]*PB[1,2] - 0.25*(1 + p/sqrt(2))*Id,\n               PA[1,2]*PB[1,1] - 0.25*(1 + p/sqrt(2))*Id,\n               PA[1,2]*PB[1,2] - 0.25*(1 - p/sqrt(2))*Id]\n\n# This returns about 0.7467 for p = 0.9 at level 2 using the default SCS\n# solver.\nnpa_max(G, 2, eq=constraints)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"QuantumNPA calls the SCS solver by default (since it doesn't require a license) to solve the NPA relaxation of a quantum optimisation problem, but a keyword argument solver lets you specify a different one. E.g., solve a problem using Mosek (which you need a license file to use):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> using MosekTools\n\njulia> npa_max(S, 2, solver=Mosek.Optimizer)\n2.82842711211242","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"You can also change the default solver if you don't want to specify it every time, e.g.,","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> set_solver!(Mosek.Optimizer)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If you want to construct a JuMP model and solve it separately:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> model = npa2jump(S, \"1 + A B\", solver=SCS.Optimizer)\nA JuMP Model\nMinimization problem with:\nVariables: 45\nObjective function type: AffExpr\n`AffExpr`-in-`MathOptInterface.EqualTo{Float64}`: 16 constraints\n`Vector{VariableRef}`-in-`MathOptInterface.PositiveSemidefiniteConeTriangle`: 1 constraint\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: SCS\n\njulia> optimize!(model)\n------------------------------------------------------------------\n               SCS v3.2.0 - Splitting Conic Solver\n        (c) Brendan O'Donoghue, Stanford University, 2012\n------------------------------------------------------------------\nproblem:  variables n: 45, constraints m: 61\ncones:    z: primal zero / dual free vars: 16\n          s: psd vars: 45, ssize: 1\nsettings: eps_abs: 1.0e-04, eps_rel: 1.0e-04, eps_infeas: 1.0e-07\n          alpha: 1.50, scale: 1.00e-01, adaptive_scale: 1\n          max_iters: 100000, normalize: 1, rho_x: 1.00e-06\n          acceleration_lookback: 10, acceleration_interval: 10\nlin-sys:  sparse-direct\n          nnz(A): 81, nnz(P): 0\n------------------------------------------------------------------\n iter | pri res | dua res |   gap   |   obj   |  scale  | time (s)\n------------------------------------------------------------------\n     0| 2.22e+01  1.00e+00  2.00e+02 -9.98e+01  1.00e-01  1.40e-04 \n    75| 1.51e-05  5.94e-08  5.35e-08  2.83e+00  1.00e-01  3.10e-03 \n------------------------------------------------------------------\nstatus:  solved\ntimings: total: 3.48e-03s = setup: 3.66e-04s + solve: 3.11e-03s\n         lin-sys: 2.47e-04s, cones: 2.58e-03s, accel: 1.57e-05s\n------------------------------------------------------------------\nobjective = 2.828427\n------------------------------------------------------------------\n\njulia> objective_value(model)\n2.8284273129779325","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If you call npa2jump() without the solver keyword argument then a solver isn't assigned, and you will have to assign one to the JuMP model using JuMP's set_optimizer() function. You can also suppress the output of the solver by either calling npa2jump() with the keyword argument verbose set to false or by using JuMP's set_silent() function on the returned JuMP model.","category":"page"},{"location":"npa/#Moment-matrix-generation","page":"NPA","title":"Moment matrix generation","text":"","category":"section"},{"location":"npa/#Functions","page":"NPA","title":"Functions","text":"","category":"section"},{"location":"npa/#QuantumNPA.npa_moment-Tuple{Vector}","page":"NPA","title":"QuantumNPA.npa_moment","text":"npa_moment(operators)\n\nConstruct the NPA moment matrix, given a vector of operators (monomials or polynomials). The moment matrix returned is a representation of the real part of the moment matrix, i.e., the moment matrix plus its complex conjugate divided by two. It is returned in the form of a polynomial with sparse matrices as the monomials.\n\nExamples\n\njulia> gamma = npa_moment([Id, A1, A2, B1, B2]);\n\njulia> gamma[A1]\n5×5 SparseArrays.SparseMatrixCSC{Float64, Int64} with 2 stored entries:\n  ⋅   1.0   ⋅    ⋅    ⋅\n 1.0   ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅\n\njulia> QuantumNPA.repack(gamma)\n5×5 Matrix{Polynomial}:\n Id  A1     A2     B1     B2\n A1  Id     A1 A2  A1 B1  A1 B2\n A2  A1 A2  Id     A2 B1  A2 B2\n B1  A1 B1  A2 B1  Id     B1 B2\n B2  A1 B2  A2 B2  B1 B2  Id\n\njulia> gamma = npa_moment([Id, A1 + A2, A1 - A2]);\n\njulia> gamma[A1]\n3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n  ⋅   1.0  1.0\n 1.0   ⋅    ⋅\n 1.0   ⋅    ⋅\n\n\njulia> gamma[A2]\n3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n   ⋅   1.0  -1.0\n  1.0   ⋅     ⋅\n -1.0   ⋅     ⋅\n\njulia> QuantumNPA.repack(gamma)\n3×3 Matrix{Polynomial}:\n Id       A1 + A2             A1 - A2\n A1 + A2  2.0 Id + 2.0 A1 A2  0\n A1 - A2  0                   2.0 Id - 2.0 A1 A2\n\n\n\n\n\n","category":"method"},{"location":"npa/#QuantumNPA.npa_moment-Tuple{Any, Any}","page":"NPA","title":"QuantumNPA.npa_moment","text":"npa_moment(source, level)\n\nConstructs the NPA moment matrix at the given level of the hierarchy, taking all degree 1 monomials appearing in source as the level 1 operators. source can be a monomial, polynomial, or collection containing monomials, polynomials, or sub-collections. The level can be a nonnegative integer or a string, such as \"1 + A B\".\n\n\n\n\n\n","category":"method"},{"location":"npa/#QuantumNPA.npa2sdp-Tuple{Any, Any}","page":"NPA","title":"QuantumNPA.npa2sdp","text":"npa2sdp(expr, level; eq=[], ge=[])\n\nGenerate the NPA relaxation for a given quantum optimisation problem, at the indicated level of the NPA hierarchy.\n\nThis basically uses the npa_moment function to generate the moment matrix and then calls npa2sdp again with the moment matrix as the second argument, which takes the real part of the problem and then eliminates the equality constraints by substitution.\n\nExample\n\njulia> S = A1*(B1 + B2) + A2*(B1 - B2)\nA1 B1 + A1 B2 + A2 B1 - A2 B2\n\njulia> (objective, moments) = npa2sdp(S, 1, eq=[A2*B1 - Id]);\n\njulia> objective\nId + A1 B1 + A1 B2 - A2 B2\n\njulia> moments[1][Id]\n5×5 SparseArrays.SparseMatrixCSC{Float64, Int64} with 7 stored entries:\n 1.0   ⋅    ⋅    ⋅    ⋅\n  ⋅   1.0   ⋅    ⋅    ⋅\n  ⋅    ⋅   1.0  1.0   ⋅\n  ⋅    ⋅   1.0  1.0   ⋅\n  ⋅    ⋅    ⋅    ⋅   1.0\n\njulia> QuantumNPA.repack(moments[1])\n5×5 Matrix{Polynomial}:\n Id  A1     A2     B1     B2\n A1  Id     A1 A2  A1 B1  A1 B2\n A2  A1 A2  Id     Id     A2 B2\n B1  A1 B1  Id     Id     B1 B2\n B2  A1 B2  A2 B2  B1 B2  Id\n\n\n\n\n\n","category":"method"},{"location":"#QuantumNPA.jl","page":"Home","title":"QuantumNPA.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Maximise CHSH:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using QuantumNPA\n\njulia> @dichotomic A1 A2 B1 B2;\n\njulia> S = A1*(B1 + B2) + A2*(B1 - B2);\n\njulia> npa_max(S, 2)\n2.828227712681755","category":"page"},{"location":"","page":"Home","title":"Home","text":"Gamma_ij = langle O^dagger_i O_j rangle","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\", \"examples.md\", \"npa.md\"]\nDepth = 2","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
